# Сравнение лексикографического порядка строк с использованием SEQ и MPI технологий

- **Студент**: Крымова Кристина Дмитриевна, 3823Б1ПМоп3 
- **Технология**: SEQ, MPI
- **Вариант**: 26

## 1. Введение
- **Мотивация**: Изучить применение MPI для параллельного сравнения строк лексикографическим порядком, оценить эффективность распределения вычислений между процессами.
- **Проблема**: Задача сравнения строк лексикографическим порядком возникает во многих приложениях (сортировка, поиск, анализ текста). При работе с очень длинными строками последовательный алгоритм может быть медленным.
- **Ожидаемый результат**: MPI версия должна показать ускорение за счет распределения сравнения символов между несколькими процессами.

## 2. Постановка задачи
На вход программе подаются 2 строки. Требуется определить их лексикографический порядок:
- Возвращает -1, если первая строка меньше второй
- Возвращает 0, если строки равны  
- Возвращает 1, если первая строка больше второй

Алгоритм сравнения:
1. Сравнивать символы строк попарно до первого различия
2. Если найдено различие - определить порядок на основе этих символов
3. Если различий нет - сравнить длины строк

## 3. Базовый алгоритм (последовательный)
Последовательный алгоритм проходит по символам обеих строк до первого различия или до конца более короткой строки.

```cpp
bool KrymovaKLexSEQ::RunImpl() {
  const std::string &str1 = std::get<0>(GetInput());
  const std::string &str2 = std::get<1>(GetInput());

  size_t len1 = str1.length();
  size_t len2 = str2.length();
  size_t min_len = (len1 < len2) ? len1 : len2;
  
  for (size_t i = 0; i < min_len; ++i) {
    if (str1[i] != str2[i]) {
      GetOutput() = (str1[i] < str2[i]) ? -1 : 1;
      return true;
    }
  }
  
  if (len1 < len2) {
    GetOutput() = -1;
  } else if (len1 > len2) {
    GetOutput() = 1;
      } else {
    GetOutput() = 0;
  }
  return true;
}
```
## 4. Описание параллельного алгоритма

Параллельный алгоритм основан на последовательной версии, основное отличие заключается в распределении сравнения символов между несколькими процессами. Распределение работы происходит следующим образом:

1. **Разделение диапазона сравнения**: Область сравнения (минимальная длина из двух строк) делится между процессами примерно поровну. Каждый процесс получает непрерывный участок символов для проверки.

2. **Локальная обработка**: Каждый процесс независимо проверяет свой участок строк, находя первое различие в своем диапазоне (если такое существует). Поиск прекращается при нахождении первого различия в локальном диапазоне.

3. **Глобальная синхронизация**: Для определения окончательного результата используются две операции MPI_Allreduce:
   - Первая операция (MPI_MAX) определяет, найдено ли различие любым из процессов
   - Вторая операция (MPI_MIN) находит самую левую позицию различия среди всех процессов

4. **Определение результата**:
   - Если различие найдено, лексикографический порядок определяется по символам в самой левой позиции различия
   - Если различий не найдено, результат определяется на основе сравнения длин исходных строк

Алгоритм эффективно распределяет нагрузку и минимизирует коммуникационные затраты, используя всего две коллективные операции для синхронизации всех процессов.

## 5. Experimental Setup

**Hardware/OS**: Apple MacBook Air with Apple M1 Chip (8 cores: 4 performance + 4 efficiency), 8 GB RAM, macOS

**Toolchain**: Apple Clang version 16.0.0, сборка через VSCode с оптимизацией (-O2/-O3)

**Data**: Для тестирования производительности использовались строки длиной 10,000,000 символов с различием в последнем символе

## 6. Результаты

### 6.1 Корректность

Корректность алгоритмов проверена 8 функциональными тестами, покрывающими различные сценарии:

- Равные строки
- Разные первые символы  
- Различия в середине строк
- Строки разной длины

## 6.2 Производительность

На основе данных из perf_log.txt (строки длиной 10,000,000 символов):

| Mode | Test Case | Time, s | Speedup vs SEQ |
|------|-----------|---------|----------------|
| SEQ  | krymova_k_lex_order | 0.00314 | 1.00x |
| MPI  | krymova_k_lex_order | 0.00165 | 1.90x |

**Примечание**: SEQ версия показывает время 0.00314 секунд, MPI версия - 0.00165 секунд, что дает ускорение в ~1.9 раза.

## 7. Выводы

1. **Эффективность MPI**: MPI версия демонстрирует ускорение ~1.9x благодаря параллельной обработке участков строк
2. **Масштабируемость**: Задача хорошо распараллеливается, так как сравнение символов в разных участках независимо
3. **Коммуникационная эффективность**: Использование MPI_Allreduce минимизирует накладные расходы на синхронизацию
4. **Практическая применимость**: Полученное ускорение подтверждает целесообразность использования MPI для задач лексикографического сравнения больших строк

## 8. Литература
1. Стандарт MPI.
2. Лекции и практики по параллельному программированию.

## 9. Приложение

```cpp
bool KrymovaKLexOrderMPI::RunImpl() {
  const std::string &str1 = std::get<0>(GetInput());
  const std::string &str2 = std::get<1>(GetInput());

  int rank = 0;
  int size = 1;
  MPI_Comm_rank(MPI_COMM_WORLD, &rank);
  MPI_Comm_size(MPI_COMM_WORLD, &size);

  size_t len1 = str1.length();
  size_t len2 = str2.length();
  size_t min_len = std::min(len1, len2);

  size_t chunk_size = (min_len + size - 1) / size;
  size_t start = rank * chunk_size;
  size_t end = std::min(start + chunk_size, min_len);
  bool found_diff = false;
  int local_diff_pos = -1;

  for (size_t i = start; i < end; ++i) {
    if (str1[i] != str2[i]) {
      found_diff = true;
      local_diff_pos = static_cast<int>(i);
      break;
    }
  }
  int local_found = found_diff ? 1 : 0;
  int global_found = 0;
  MPI_Allreduce(&local_found, &global_found, 1, MPI_INT, MPI_MAX, MPI_COMM_WORLD);

  int result = 0;

  if (global_found != 0) {
    int pos_to_send = found_diff ? local_diff_pos : INT_MAX;
    int global_min_pos = 0;
    MPI_Allreduce(&pos_to_send, &global_min_pos, 1, MPI_INT, MPI_MIN, MPI_COMM_WORLD);
    result = (str1[global_min_pos] < str2[global_min_pos]) ? -1 : 1;
  } else {
    if (len1 < len2) {
      result = -1;
    } else if (len1 > len2) {
      result = 1;
    }
  }

  GetOutput() = result;
  return true;
}
```