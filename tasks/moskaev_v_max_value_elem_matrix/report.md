#<Максимальное значение элементов матрицы>
Студент: Москаев Владимир Александрович, группа: 3823Б1ПМоп3

Технология: MPI, SEQ

Вариант: 13

## 1. Введение
Задача заключается в поиске максимального элемента в матрице. Цель — реализовать параллельный алгоритм поиска максимального элемента с использованием технологии MPI и сравнить его производительность с последовательной версией.

## 2. Постановка задачи
Формальная постановка: Для заданной матрицы A размером M×N найти элемент с максимальным значением.

Входные данные: Двумерный вектор std::vector<std::vector<int>> - матрица целых чисел.

Выходные данные: Целое число - максимальный элемент матрицы.

Ограничения:
Матрица может быть не квадратной
Все элементы целочисленные
Матрица гарантированно не пустая

## 3. Последовательный алгоритм:
Базовый алгоритм последовательно обходит все элементы матрицы:

int max_element = matrix[0][0];
for (const auto &row : matrix) {
    for (int element : row) {
        max_element = std::max(element, max_element);
    }
}
Сложность: O(M×N), где M - количество строк, N - количество столбцов.

## 4. Схема распараллеливания
MPI реализация
Декомпозиция данных: Матрица распределяется по строкам между процессами. Каждый процесс получает свой набор строк для обработки.

Распределение строк:
auto rows_per_process = total_rows / size;
auto remainder = total_rows % size;

size_t start_row = ((rank * rows_per_process) + 
                   (std::min(static_cast<size_t>(rank), remainder)));
size_t end_row = start_row + rows_per_process;
if (std::cmp_less(static_cast<size_t>(rank), remainder)) {
    end_row += 1;
}

Коммуникационная схема:
Каждый поцесс находит локальный максимум в своей части матрицы
Используется MPI_Allreduce для нахождения глобального максимума
Все процессы получают результат одновременно
Все процессы равноправны

## 5. Детали реализации
Структура кода:
ops_mpi.hpp/cpp - MPI реализация
ops_seq.hpp/cpp - последовательная реализация
common.hpp - общие типы данных
main.cpp - функциональные тесты
main.cpp - производительностные тесты

Ключевые классы:

MoskaevVMaxValueElemMatrixMPI - MPI версия задачи
MoskaevVMaxValueElemMatrixSEQ - последовательная версия

## 6. Экспериментальная установка
Аппаратное обеспечение:

CPU: Intel Core i5-11400H (6 cores, 12 threads)
RAM: 16 GB
OS: Windows 10


Компилятор: GCC 15.2.0


Тестовые данные:
Матрицы размеров: 10×10, 20×20, 50×50, 100×100
Для производительностных тестов: 5000×5000
Данные генерируются случайно с равномерным распределением

## 7. Результаты
### 7.1 Корректность
Корректность реализации проверяется с помощью:
Сравнения результатов MPI и последовательной версий

Все тесты проходят успешно, что подтверждает корректность реализации.

### 7.2 Производительность
Результаты для матрицы 5000×5000:


|Тест	        |Режим	  |Время (сек)	  |Ускорение   |Эффективность|
|---------------|---------|---------------|------------|-------------|
|Pipeline Run	|MPI	  |0.00369	      |4.46×	   |111.5%       |
|Task Run	    |MPI	  |0.00402	      |4.03×	   |100.8%       |
|Pipeline Run	|SEQ	  |0.01646	      |1.00×	   |N/A          |
|Task Run	    |SEQ	  |0.01622	      |1.00×	   |N/A          |

Наблюдения:
Высокая эффективность при 4 процессах

Pipeline: 4.46× ускорение при 4 процессах = 111.5% эффективности
Run: 4.03× ускорение при 4 процессах = 100.8% эффективности

Сверхлинейное ускорение: Эффективность более 100% указывает на сверхлинейное ускорение, это возможно связано с:
При распределении матрицы между 4 процессами, каждый процесс работает с меньшим объемом данных, который лучше помещается в кэш процессора

## 8. Выводы
Успешно реализованы последовательная и MPI версии алгоритма поиска максимального элемента

Достигнуто отличное ускорение - до 4.46× на 4 процессах